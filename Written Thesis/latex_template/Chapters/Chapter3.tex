% Chapter 3

\chapter{Rigid Body Motion} % Main chapter title

\label{Chapter3} % For referencing the chapter elsewhere, use \ref{Chapter1} 

\lhead{Chapter 3. \emph{Rigid Body Motion}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------

Previous chapters have disregarded rotational motion of solid bodies.  This chapters examines the mechanics of rigid body rotations through angular momentum fixed axis rotation.  Simulations will involve rotation of a rigid body experiencing a torque.


\section{Angular Momentum and Torque}

Previous sections in this thesis have simply involved translational motion.  The theorem of rigid body motion states that the displacement of any rigid body can be decomposed into two independent motions: the translation of the center of mass, and the rotation about the center of mass.  A rigid body in general is defined as an object that maintains its shape and size when a force is applied to it.  In reality, all objects experience some level of deformation, however for the purpose of these simulations it is safe to ignore this.  

To rotate a rigid body about an axis, a force must be applied to create a moment of torque, given by the equation below:

\begin{equation} \label{eq:torquegeneral}
\vec{\tau} = \vec{r} \times \vec{F}
\end{equation}


Where $\vec{r}$ is the vector from center of rotation to the point of application of force.  If the force applied has a line of action that intersects the center of mass of the object, no torque is produced.  To simplify the simulations involving toruqe, all objects are polygons with an assumed uniform density.  Therefore, the center of mass would always be the geometric center of the polygon.  The center of mass is essential for simulations becuase it is the reference point that allows the simulations to involve both translational and rotational motion. 

While moment of torque represents resistance to angular motion, moment of inertia represents resistance to angular \textit{acceleration}.  For a continuous distribution of mass like a rigid body, the moment of intertia is defined by the following:

\begin{equation}\label{momentofintertia}
I =   \int  r^2 dm
\end{equation}

Lastly, while linear momentum is related to translational motion, angular momentum is related to rotational motion.  Angular momentum is defined by:  $\vec{L} = \vec{r} \times \vec{p}$.  A rigid body can be interpreted as a collection of particles all rotating with the same angular velocity $\omega$, which allows for the following equation:

\begin{equation}
L = \mathlarger{\mathlarger{\mathlarger{\Sigma}}} m_i r_i^2 \omega
\end{equation}

Using the definition of moment of inertia, the above equation can be written as:

\begin{equation}
\vec{L} = I \vec{\omega}
\end{equation}

Understanding these fundamental equations is the background for Newton's Second Law for rotational motion, which is essential for rigid body simulations.  Any rigid body can be visualized as a collection of infinitely small particles of mass $dm$, as shown below:

\begin{figure}[h] 
	\centering
		\includegraphics[width=7cm]{Figures/rigidbody.png}

	\caption{Diagram of rigid body with center of mass O}
	\label{fig:rigidbody}
\end{figure}

Understanding the equation $a = r \alpha$ and substituting into Newton's 2nd law yields the following:

\begin{equation}
F = mr\alpha
\end{equation}

Manipulating the scalar equation for torque of $T = Fr$ and combining with the above equation yields:

\begin{equation}
T = \mathlarger{\mathlarger{\mathlarger{\Sigma}}} m r^2 \alpha
\end{equation}

Again, understanding the equation for moment of inertia, and subsituting back for vectors yields the following:

\begin{equation}\label{eq:Newtonaccel}
\vec{T} = I \vec{\alpha}
\end{equation}

This formula is analagous to the common Newton's 2nd law of  $F = ma$ for rotational motion, instead of translational motion.  From this equation, the angular acceleration of any rigid body can be calculated from the torque, which is essential for creating simulations of rigid body rotation.  

\section{The Code}

To create a basic simulation of an object experiencing torque, it is crucial to understand how to incorporate rotation.   This is done with the following code:

 \setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=Code to rotate an object, label=lst:rotation]
rotate: function(angle){
		return new Vector2D(this.x*Math.cos(angle)-this.y*Math.sin(angle),this.x*Math.sin(angle)+this.y*Math.cos(angle));
	}	
\end{lstlisting}
\setstretch{2}

The rotate method of the Vector2D object returns the updated vector based on the value of the angle argument when the method is called.  The rotate method can be derived using trigonometry, and by understanding the unique difference of the canvas coordinate system described in the introduction.  Essentially, for an angle of rotation $\theta$, the resultant vector would be $(xcos\theta - ysin\theta)\imath + (xsin\theta + ycos\theta)\jmath$.  The remaining code of the torque simulation is shown below:  





\vspace{5mm}
\setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=Code for angular rotation simulation, label=lst:angularrotation]
var rigidBody;
var acc, force;	
var alp, torque;
var t0, dt;
var animId;
var kLin = 0.05; // linear damping factor	
var kAng = .5; // // angular damping factor	

window.onload = init; 

function init() {
	var v1 = new Vector2D(-100,100);
	var v2 = new Vector2D(100,100);
	var v3 = new Vector2D(100,-100);
	var v4 = new Vector2D(-100,-100);
	var vertices = new Array(v1,v2,v3,v4);
	rigidBody = new PolygonRB(vertices);
	rigidBody.mass = 1;
	rigidBody.im = 5;
	rigidBody.pos2D = new Vector2D(500,200);	
	rigidBody.velo2D = new Vector2D(30, 0);			
	rigidBody.angVelo = 0;	
	rigidBody.draw(context);
	t0 = new Date().getTime(); 
	animFrame();
};

function animFrame(){
	animId = requestAnimationFrame(animFrame,canvas);
	onTimer(); 
}
function onTimer(){
	var t1 = new Date().getTime(); 
	dt = 0.001*(t1-t0); 
	t0 = t1;
	if (dt>0.2) {dt=0;};	
	move();
}
function move(){			
	moveObject(rigidBody);
	calcForce(rigidBody);
	updateAccel(rigidBody);
	updateVelo(rigidBody);
}
function moveObject(obj){
	obj.pos2D = obj.pos2D.addScaled(obj.velo2D,dt);	
	obj.rotation = obj.angVelo*dt;
	context.clearRect(0, 0, canvas.width, canvas.height);
	obj.draw(context);	
}
function calcForce(obj){
	force = Forces.zeroForce();
	force = force.addScaled(obj.velo2D,-kLin); // linear damping
	torque = 1;
	torque += -kAng*obj.angVelo; // angular damping 	
}	
function updateAccel(obj){
	acc = force.multiply(1/obj.mass);
	alp = torque/obj.im;
}	
function updateVelo(obj){
	obj.velo2D = obj.velo2D.addScaled(acc,dt);	
	obj.angVelo += alp*dt;	
}
\end{lstlisting}
\setstretch{2}

This simulation involves a block that begins with an initial velocity, but zero force.  To simulate air resistance or friction, the block eventually comes to rest, programmed by a linear velocity damping coefficient.  The block begins with a certain amount of torque, represented by line 54.  This quantity is unitless and means nothing except for an initial value that could be perceived as the force brining the block into motion.  The block experiences a negative torque througout its rotation, which could be interpreted as air resistance.  Eventually, the torque reaches 0, and the block has achieved rotational equilibrium: the angular velocity is constant.  An interesting line of code is line 59, which updates the angular acceleration of the object.  This is the line of code that connects to Newton's 2nd law for rotation, equation \ref{eq:Newtonaccel} stated previously.  

The angular velocity begins at 0 in this simulation, but is changed by the angular acceleration, similar to how the translational velocity is changed by the translational acceleration.  The object is rotated appropriately according to the method of listing \ref{lst:rotation}.  

Like some other simulations in this book, an external library of some code was used to speed up the development process.  However, this library features simple methods like finding the distance between two vectors.  These libraries of ``tools'' code are shown in the appendices.  
















% \section{Rigid Body Collision}



