% Chapter 1

\chapter{Simulating Orbits} % Main chapter title

\label{Chapter2} % For referencing the chapter elsewhere, use \ref{Chapter1} 

\lhead{Chapter 2. \emph{Simulating Orbits}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------

In this chapter, a more advanced simulation of orbiting masses will be introduced.  First, a simple orbit situation will be introduced, followed by more complex examples involving escape velocities.  While the physics still isn't too advanced, the coding necessary is a bit more challenging.  



\section{Basic Orbit Path}

The first simulation will deal with an example of a planet orbiting another much more massive planet.  

\subsection{Background Physics}



This entire chapter is centered around Newton's law of universal gravitation:

\begin{equation}\label{universalgravity}
F_g = G \frac{m_1 m_2}{r^2} 
\end{equation}

Where $F_g$ is the magnitude of the force acting on either mass, G is the gravitational constant ( SI units of $6.67 \hspace{1mm} \frac{Nm^2}{kg^2}$ ), $m_1$ is the mass of one object, $m_2$ is the mass of the other object, and $r$ is the radius separating the two masses.  By Newton's 3rd law, there is an equal and opposite force exerted on each mass.  

This equation can be used to describe the orbiting paths of planets.  For simple cases when one planet orbits another, the variables m and M can be used.  For a first example, we will assume M \textgreater \textgreater  m, that is, one planet has a much greater mass than the other.  Therefore, while each planet exerts an equal force on the other, the acceleration on the massive planet will be negligible.  So, the smaller planet will orbit around the stationary planet, without attracting the larger planet enough to move it.  




\subsection{The Code}  

The full code is shown in the listing below:

\setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=Basic planet orbiting simulation, label=lst:basicorbit]
var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d'); 
var canvas_bg = document.getElementById('canvas_bg');
var context_bg = canvas_bg.getContext('2d');

var planet;
var sun;
var m = 1; // planet's mass
var M = 1000000; // heavy planet's mass
var G = 1;
var t0,dt;

window.onload = init; 

function init() {
	// create a stationary large planet
	sun = new Ball(70,'orange',M);
	sun.pos2D = new Vector2D(275,200);	
	sun.draw(context_bg);
	// create a moving planet			
	planet = new Ball(10,'blue',m);
	planet.pos2D = new Vector2D(200,50);
	planet.draw(context);
	// make the planet orbit the large planet
	t0 = new Date().getTime(); 
	animFrame();
};

function animFrame(){
	animId = requestAnimationFrame(animFrame,canvas);
	onTimer(); 
}
function onTimer(){
	var t1 = new Date().getTime(); 
	dt = 0.001*(t1-t0); 
	t0 = t1;	
	if (dt>0.1) {dt=0;};	
	move();
}
function move(){			
	moveObject(planet);
	calcForce();
	updateAccel();
	updateVelo(planet);
}

function moveObject(obj){
	obj.pos2D = obj.pos2D.addScaled(obj.velo2D,dt);	
	context.clearRect(0, 0, canvas.width, canvas.height);
	obj.draw(context);	
}
function calcForce(){
	force = Forces.gravity(G,M,m,planet.pos2D.subtract(sun.pos2D));	
}	
function updateAccel(){
	acc = force.multiply(1/m);
}	
function updateVelo(obj){
	obj.velo2D = obj.velo2D.addScaled(acc,dt);				
}
\end{lstlisting}
\setstretch{2}

This program differs from previous ones used so far in that it uses two canvases instead of one.  This is essential for having the large planet remain stationary and not being erased every frame.  Instead, there can be a constant ``background'' canvas containing the stationary planet.  The code begins by initializing the variables planet and sun, where sun simply refers to any large planet that has much more mass.  The gravitational constant $G$ is intialized as a formality just to a value of 1.  G in this simulation isn't necessary, because the constant simply is used for unit conversion.  This will become clear later in this section.  When the web page is loaded, it calls the init function, just as in previous simulations.  The init function creates the sun and planet as objects from the Ball constructor function, exactly as in chapter 1.  Instead of having separate variables x and y in the previous examples, the position information can be stored into a property of each object, which is created using a different constructor function Vector2D.  

The next function, animFrame, functions simply by initializing the javascript animation frame, and then calling the next function, onTimer.  This next function creates a variable dt by converting the unit javascript operates in (ms) to SI units of s.  It then passes the flow of the program onto the next function, move.  This function involves calling 4 functions, the first of which simply updates the position of the planet, erases the foreground canvas, and then draws the updated canvas.  This step can be analyzed through a physics kinematics equation:

\begin{equation}\label{velo}
x(t+dt) = x(t) + v_x(t)dt
\end{equation}

This is essentially analagous to Euler's method, by understanding that $v_x = \frac{dx}{dt}$.  

\begin{equation}\label{euler}
x(t+dt) = x(t) + \frac{dx}{dt}\left(0\right) dt
\end{equation}

By using constructor functions, with 2 different properties for the x and y position, the planet's location can be updated without updating variables and taking up more space.  The location has to be updated for every frame, but so does the force, acceleration, and velocity.  These next 3 steps are the remaining functions of the move function.  The calcForce function updates the force of gravity acting on the planet, using equation \ref{universalgravity}.  This equation calculates r by calculating the displacement vector between the two planets, and finding the magnitude of that vector.  The updateAccel function simply takes the updated force vector and scales it by a certain ``k'' value which is represented by dividing by the mass.  This is the step that incorporates Newton's 2nd law of $a = \frac{F}{m} $.  The last function updates the velocity of the planet, similar to how the position was updated.  Using Euler's method like before, we come to the following equation

\begin{equation}\label{euleraccel}
 v (t+dt) =  v(t) + a(t)dt 
\end{equation}





Essentially, what makes this program more complicated is that it uses many other functions to accomplish the overall simulation.  However, this method of programming makes future simulations easier--the same functions can be used, with changed variables.  The code listing below shows these ``tool'' functions that are used in future chapters of this thesis:

\setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=Various tools functions used for orbit simulation, label=lst:basicorbittools]
function Vector2D(x,y) {
	this.x = x;
	this.y = y;		
}	
Vector2D.prototype = {		
	lengthSquared: function(){
		return this.x*this.x + this.y*this.y;
	},
	length: function(){
		return Math.sqrt(this.lengthSquared());
	},
	add: function(vec) {
		return new Vector2D(this.x + vec.x,this.y + vec.y);
	},
	subtract: function(vec) {
		return new Vector2D(this.x - vec.x,this.y - vec.y);
	},
	multiply: function(k) {
		return new Vector2D(k*this.x,k*this.y);
	},
	addScaled: function(vec,k) {
		return new Vector2D(this.x + k*vec.x, this.y + k*vec.y);
	},	

	function Forces(){
}
Forces.gravity = function(G,m1,m2,r){
	return r.multiply(-G*m1*m2/(r.lengthSquared()*r.length()));
}
\end{lstlisting}
\setstretch{2}


\section{Escape Velocity}

The previous section tested situations where the planet orbited the sun continuously.  However, if the speed is great enough, the orbiting body is capable of ``escaping'' from the larger planet's influence.  The minimum speed necessary for this is called the escape velocity.  

This can be derived by understanding conversation of energy.  When an object leaves the surface of a planet, it will have an initial kinetic energy, and potential gravitational energy.  This will equal the final potential energy, defined as a condition when the final kinetic and gravitational potential energy is 0.  This relationship is shown in the equation below:

$$K_i + U_{g_{i}} = K_f + U_{g_{f}}$$

Knowing that the final kinetic and gravitational energy is 0, this equation becomes:

$$\frac{1}{2}mv_{esc}^2 - \frac{GMm}{r} = 0 + 0  $$

Solving for $v_{esc}$ yields the following:

\begin{equation}\label{eq:escapevelocity}
v_{esc} = \sqrt{\frac{2GM}{r}}
\end{equation}

Where G is the gravitational constant, M is the mass of the planet the object is escaping from, and r is the starting distance from the center of mass of the planet.  

To test the physics behind the escape velocity, a slightly different scenario can be created with a different program.  This simulation will have the object begin right at the surface of the larger planet, to emulate the process of ``escaping'' from the planet's gravity influence.  To visualize this, a much larger canvas will be used, and some code changes will be utilized, seen below:


\setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=New conditions for escape velocity simulation, label=lst:changestoorbit]
sun = new Ball(400,'orange',M);
sun.pos2D = new Vector2D(

planet = new Ball(10,'blue',m);
planet.pos2D = new Vector2D(500,2490);

planet.velo2D = new Vector2D(0, -80);
\end{lstlisting}
\setstretch{2}

These changes made the larger planet look visually bigger, to simulate the effect of a massive planet.  It also positioned the object to begin right on the surface of the larger planet (in this case, 410 pixels above the center of mass of the larger planet).  To calculate the escape velocity for the situation above, equation \ref{eq:escapevelocity} can be used, but understanding some key factors:

\begin{enumerate}
\item The escape velocity calculated will be in $\frac{px}{s}$ instead of SI unit $\frac{m}{s}$
\item The masses of each planet don't need to contain units, it can more just represent a ratio between the large and small planet.  Therefore, each mass will be a unitless quantity, just used as a test of the escape velocity equation.
\item Similarly to  \#2, the gravitational constant G doesn't have to include units, since this test is only in a more theoretical sense, and doesn't use actual units of mass.  However, using dimensional analysis, for the equation below to make sense, G could be viewed as having units of $\frac{px^3}{s^2}$.
\end{enumerate}

Proceeding with these conditions in mind, the escape velocity for the simulation of code listing \ref{lst:updatedorbit}
can be calculated as shown below:

\begin{equation}\label{eq:calcvescape}
 v_{esc} = \sqrt{\frac{2*1 \frac{px^3}{s^2}*1000000}{410 px}} \approx 69.843 \frac{px}{s} 
\end{equation}

Therefore, with the program simulation, any initial speed greater than this value will escape the gravitational influence of the larger planet.  To test this, I used the following code to print out values of the velocity continuously:

\setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=Code for printing out values of speed, label=lst:changestoorbit]
var i =0;
i++;
if(i%15 ===0){console.log(planet.velo2D.length());}
\end{lstlisting}
\setstretch{2}

This code operates by printing out the value of the speed of object 4 times per second, understanding that i is incremented by 1 for each frame, and there are the usual 60 frames per second.  The data is outputted through the console.log() method, which prints it onto the web browser.  This data was then plotted for different initial speeds, and the results are shown below:






















\section{Kepler's Laws}






























