% Appendix D

\chapter{``Tools'' Code Used From Dev Ramtal Book} % Main appendix title

\label{AppendixD} % For referencing this appendix elsewhere, use \ref{AppendixA}

\lhead{Appendix D. \emph{``Tools'' Code Used From Dev Ramtal Book }} % This is for the header on each page - perhaps a shortened title


\section{Vector 2D Code}
\setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=Vector code used to find various calculations of vectors]
function Vector2D(x,y) {
  this.x = x;
  this.y = y;   
}   

// PUBLIC METHODS 
Vector2D.prototype = {    
  lengthSquared: function(){
    return this.x*this.x + this.y*this.y;
  },
  length: function(){
    return Math.sqrt(this.lengthSquared());
  },  
  angle: function(){
    return Math.atan2(this.y,this.x);
  },  
  add: function(vec) {
    return new Vector2D(this.x + vec.x,this.y + vec.y);
  },
  incrementBy: function(vec) {
    this.x += vec.x;
    this.y += vec.y;
  },    
  subtract: function(vec) {
    return new Vector2D(this.x - vec.x,this.y - vec.y);
  },
  decrementBy: function(vec) {
    this.x -= vec.x;
    this.y -= vec.y;
  },    
  multiply: function(k) {
    return new Vector2D(k*this.x,k*this.y);
  },    
  addScaled: function(vec,k) {
    return new Vector2D(this.x + k*vec.x, this.y + k*vec.y);
  },  
  scaleBy: function(k) {
    this.x *= k;
    this.y *= k;
  },
  rotate: function(angle){
    return new Vector2D(this.x*Math.cos(angle)-this.y*Math.sin(angle),this.x*Math.sin(angle)+this.y*Math.cos(angle));
  } 
};    

// STATIC METHODS
Vector2D.distance =  function(vec1,vec2){
  return (vec1.subtract(vec2)).length(); 
}
Vector2D.angleBetween = function(vec1,vec2){
  return Math.acos(vec1.dotProduct(vec2)/(vec1.length()*vec2.length()));
}
Vector2D.scale = function(vec,sca){
  vec.x *= sca;
  vec.y *= sca;
}
\end{lstlisting}









\section{Forces Code}
\setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=Code used involving forces]
function Forces(){
}

// STATIC METHODS
Forces.zeroForce = function() {
  return (new Vector2D(0,0));
}
Forces.constantGravity = function(m,g){
  return new Vector2D(0,m*g);
}
Forces.gravity = function(G,m1,m2,r){
  return r.multiply(-G*m1*m2/(r.lengthSquared()*r.length()));
}
Forces.linearDrag = function(k,vel){
  var force;
  var velMag = vel.length();
  if (velMag > 0) {
    force = vel.multiply(-k);
  }else {
    force = new Vector2D(0,0);
  }
  return force;
}
Forces.add = function(arr){
    var forceSum = new Vector2D(0,0);
    for (var i=0; i<arr.length; i++){
    var force = arr[i];
    forceSum.incrementBy(force);
  }
  return forceSum;
}
\end{lstlisting}









\section{Polygon Code}
\setstretch{1}
\begin{lstlisting}[breaklines=true, frame=single, numbers=left, caption=Code used to create and manipulate polygon rigid bodies]
// dependencies: Vector2D
function PolygonRB(vertices,color,mass,momentOfInertia){
  if(typeof(color)==='undefined') color = '#0000ff';
  if(typeof(mass)==='undefined') mass = 1;  
  if(typeof(momentOfInertia)==='undefined') momentOfInertia = 1;  
  this.vertices = vertices;
  this.color = color;
  this.mass = mass;
  this.im = momentOfInertia;
  // x and y also define the center of mass
  this.x = 0;
  this.y = 0;
  this.vx = 0;
  this.vy = 0;  
  this.angVelo = 0; 
  this.theta = 0;
}   

PolygonRB.prototype = {
  get pos2D (){
    return new Vector2D(this.x,this.y);     
  },
  set pos2D (pos){
    this.x = pos.x;
    this.y = pos.y;
  },
  get velo2D (){
    return new Vector2D(this.vx,this.vy);     
  },
  set velo2D (velo){
    this.vx = velo.x;
    this.vy = velo.y;
  },    
  get rotation (){
    return this.theta;
  },  
  set rotation (angle){ 
    this.theta = angle;
    for (var i=0; i<this.vertices.length; i++){
      this.vertices[i] = this.vertices[i].rotate(angle);
    }
  },  
  // returns the vertex furthest from the center of mass
  get maxVertex(){
    var vertex = 0;
    for(var i=1;i<this.vertices.length;i++){
      if(this.vertices[i].length()>vertex){
        vertex = this.vertices[i].length();
      }
    }
    return vertex;
  },  
  get sides(){
    var sidesArr = new Array();
    var side;
    for(var i=0; i<this.vertices.length-1; i++){
      side = this.vertices[i+1].subtract(this.vertices[i]);
      sidesArr.push(side);
    }
    side = this.vertices[0].subtract(this.vertices[i]);
    sidesArr.push(side);  
    return sidesArr;  
  },
  draw: function (ctx) {  
    var v = new Array();
    for (var i=0; i<this.vertices.length; i++){
      v[i] = this.vertices[i].add(this.pos2D);
    }
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.beginPath();  
    ctx.moveTo(v[0].x,v[0].y);
    for (var i=1; i<v.length; i++){
      ctx.lineTo(v[i].x,v[i].y);
    }
    ctx.lineTo(v[0].x,v[0].y);
    ctx.closePath();
    ctx.fill(); 
    ctx.restore();
  }
};
\end{lstlisting}



































